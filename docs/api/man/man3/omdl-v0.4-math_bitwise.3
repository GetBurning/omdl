.TH "math_bitwise" 3 "Thu Feb 2 2017" "Version v0.4" "omdl" \" -*- nroff -*-
.ad l
.nh
.SH NAME
math_bitwise \- Bitwise Operations
.PP
Bitwise binary (base-two) operations\&.  

.SS "Files"

.in +1c
.ti -1c
.RI "file \fBmath_bitwise\&.scad\fP"
.br
.RI "\fIMathematical bitwise binary (base-two) functions\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "function \fBbitwise_is_equal\fP (v, b, t=1)"
.br
.RI "\fITest if a base-two bit position of an integer value equals a test bit\&. \fP"
.ti -1c
.RI "function \fBbitwise_i2v\fP (v, w=1, bv=1)"
.br
.RI "\fIEncode an integer value as a base-two vector of bits\&. \fP"
.ti -1c
.RI "function \fBbitwise_v2i\fP (v)"
.br
.RI "\fIDecode a base-two vector of bits to an integer value\&. \fP"
.ti -1c
.RI "function \fBbitwise_i2s\fP (v, w=1)"
.br
.RI "\fIEncode an integer value as a base-two string of bits\&. \fP"
.ti -1c
.RI "function \fBbitwise_s2i\fP (v)"
.br
.RI "\fIDecode a base-two string of bits to an integer value\&. \fP"
.ti -1c
.RI "function \fBbitwise_and\fP (v1, v2, bv=1)"
.br
.RI "\fIBase-two bitwise AND operation for integers\&. \fP"
.ti -1c
.RI "function \fBbitwise_or\fP (v1, v2, bv=1)"
.br
.RI "\fIBase-two bitwise OR operation for integers\&. \fP"
.ti -1c
.RI "function \fBbitwise_xor\fP (v1, v2, bv=1)"
.br
.RI "\fIBase-two bitwise XOR operation for integers\&. \fP"
.ti -1c
.RI "function \fBbitwise_not\fP (v, w=1, bv=1)"
.br
.RI "\fIBase-two bitwise NOT operation for an integer\&. \fP"
.ti -1c
.RI "function \fBbitwise_lsh\fP (v, s=1, bm=1, bv=1)"
.br
.RI "\fIBase-two bitwise left-shift operation for an integer\&. \fP"
.ti -1c
.RI "function \fBbitwise_rsh\fP (v, s=1)"
.br
.RI "\fIBase-two bitwise right-shift operation for an integer\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Bitwise binary (base-two) operations\&. 

See Wikipedia binary \fCnumbers\fP and \fCoperations\fP for more information\&.
.PP
See validation \fBresults\fP\&. 
.SH "Function Documentation"
.PP 
.SS "function bitwise_and (v1, v2, bv = \fC1\fP)"

.PP
Base-two bitwise AND operation for integers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv1\fP <integer> An integer value\&. 
.br
\fIv2\fP <integer> An integer value\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise AND of \fCv1\fP and \fCv2\fP\&. Returns \fBundef\fP when \fCv1\fP or \fCv2\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_i2s (v, w = \fC1\fP)"

.PP
Encode an integer value as a base-two string of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIw\fP <integer> The minimum bit width\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<string> of bits base-two encoding of the integer value\&. Returns \fBundef\fP when \fCv\fP or \fCw\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_i2v (v, w = \fC1\fP, bv = \fC1\fP)"

.PP
Encode an integer value as a base-two vector of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIw\fP <integer> The minimum bit width\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<vector> of bits base-two encoding of the integer value\&. Returns \fBundef\fP when \fCv\fP or \fCw\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_is_equal (v, b, t = \fC1\fP)"

.PP
Test if a base-two bit position of an integer value equals a test bit\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIb\fP <integer> A base-two bit position\&. 
.br
\fIt\fP <bit> The bit test value [0|1]\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<boolean> \fBtrue\fP when the base-two bit position of the integer value equals \fCt\fP, otherwise returns \fBfalse\fP\&. 
.RE
.PP

.SS "function bitwise_lsh (v, s = \fC1\fP, bm = \fC1\fP, bv = \fC1\fP)"

.PP
Base-two bitwise left-shift operation for an integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIs\fP <integer> The number of bits to shift\&. 
.br
\fIbm\fP (an internal recursion loop variable)\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise left-shift of \fCv\fP by \fCs\fP bits\&. Returns \fBundef\fP when \fCv\fP or \fCs\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_not (v, w = \fC1\fP, bv = \fC1\fP)"

.PP
Base-two bitwise NOT operation for an integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIw\fP <integer> The minimum bit width\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise NOT of \fCv\fP\&. Returns \fBundef\fP when \fCv\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_or (v1, v2, bv = \fC1\fP)"

.PP
Base-two bitwise OR operation for integers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv1\fP <integer> An integer value\&. 
.br
\fIv2\fP <integer> An integer value\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise OR of \fCv1\fP and \fCv2\fP\&. Returns \fBundef\fP when \fCv1\fP or \fCv2\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_rsh (v, s = \fC1\fP)"

.PP
Base-two bitwise right-shift operation for an integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <integer> An integer value\&. 
.br
\fIs\fP <integer> The number of bits to shift\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise right-shift of \fCv\fP by \fCs\fP bits\&. Returns \fBundef\fP when \fCv\fP or \fCs\fP is not an integer\&. 
.RE
.PP

.SS "function bitwise_s2i (v)"

.PP
Decode a base-two string of bits to an integer value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <string> A value encoded as a base-two string of bits\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> value encoding of the base-two string of bits\&. Returns \fBundef\fP when \fCv\fP is not a string of bit values\&. 
.RE
.PP

.SS "function bitwise_v2i (v)"

.PP
Decode a base-two vector of bits to an integer value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv\fP <vector> A value encoded as a base-two vector of bits\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> value encoding of the base-two vector of bits\&. Returns \fBundef\fP when \fCv\fP is not a vector of bit values\&. 
.RE
.PP

.SS "function bitwise_xor (v1, v2, bv = \fC1\fP)"

.PP
Base-two bitwise XOR operation for integers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIv1\fP <integer> An integer value\&. 
.br
\fIv2\fP <integer> An integer value\&. 
.br
\fIbv\fP (an internal recursion loop variable)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
<integer> result of the base-two bitwise XOR of \fCv1\fP and \fCv2\fP\&. Returns \fBundef\fP when \fCv1\fP or \fCv2\fP is not an integer\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for omdl from the source code\&.
